Implementierungsplan: Remote Debugging & Panel-Vorschau

Hallo Copilot,

wir wollen jetzt das Feature "Remote Debugging & Panel-Vorschau" umsetzen, das wir zuvor hypothetisch besprochen haben. Das Ziel ist eine Web-Oberfläche, die gleichzeitig eine Live-Vorschau des LED-Panels und die Log-Ausgaben der seriellen Schnittstelle anzeigt.

Hier sind die Anforderungen und der technische Plan, den wir dafür umsetzen sollen:

### Teil A: ESP32-Backend

**1. Zentrales Logging-System (`MultiLogger`):**
   - Erstelle eine neue Klasse (`MultiLogger.hpp`/`.cpp`), die von der Arduino-`Print`-Klasse erbt.
   - Diese Klasse soll intern alle Ausgaben an zwei Ziele weiterleiten:
     1. An die physische `Serial`-Schnittstelle (wie bisher).
     2. In einen thread-sicheren Ringpuffer im PSRAM (z.B. für die letzten 100 Log-Zeilen).
   - Erstelle eine globale Instanz dieser Klasse (z.B. `Log`).
   - Wir werden dann im gesamten Projekt `Serial.print/println` durch `Log.print/println` ersetzen, um alle Ausgaben über dieses neue System zu leiten.

**2. WebSocket-Server:**
   - Integriere einen WebSocket-Server in den `WebServerManager`. Der Server soll unter dem Endpunkt `/stream` erreichbar sein.
   - Der Server soll maximal 2 gleichzeitige Verbindungen zulassen. Weitere Verbindungsversuche werden abgelehnt.
   - Der Server muss zwei Arten von Nachrichten unterscheiden können: Log-Nachrichten (Text) und Panel-Daten (Binär). Wir verwenden dafür ein einfaches JSON-Wrapper-Protokoll für Textnachrichten und rohe Binärdaten für das Panel.

**3. `panelStreamerTask` (Hintergrund-Task):**
   - Erstelle einen neuen FreeRTOS-Task, der auf dem zweiten CPU-Kern (Core 1) läuft, um die Hauptanwendung nicht zu blockieren.
   - **Logik des Tasks in einer Endlosschleife:**
     - Der Task prüft zuerst, ob WebSocket-Clients verbunden sind. Wenn nicht, passiert nichts und der Task geht für eine feste Zeit (z.B. 500 ms) schlafen.
     - **Panel-Streaming (z.B. 2-mal pro Sekunde):**
       - Ruft eine neue, thread-sichere Methode `panelManager->copyFullPanelBuffer()` auf, um die Rohdaten der beiden Canvases zu "fotografieren".
       - Komprimiert den 36-kB-Rohdatenpuffer mit der besprochenen Lauflängenkodierung (RLE) in einen kleineren Puffer.
       - Sendet die komprimierten Binärdaten über den WebSocket an alle verbundenen Clients.
     - **Log-Streaming (kontinuierlich):**
       - Prüft, ob neue Nachrichten im Ringpuffer des `MultiLogger` vorhanden sind.
       - Sendet jede neue Log-Zeile als Textnachricht (z.B. als JSON `{"type": "log", "data": "Log-Nachricht..."}`) über den WebSocket an alle Clients.

**4. Anpassungen im `PanelManager`:**
   - Füge einen `SemaphoreHandle_t _canvasMutex` hinzu, um den Zugriff auf die Canvas-Objekte zu schützen.
   - Implementiere die neue, öffentliche Methode `void copyFullPanelBuffer(uint16_t* destinationBuffer)`, die den Mutex verwendet, um die Daten der beiden Canvases sicher in einen Zielpuffer zu kopieren.
   - Die `render()`-Methode muss ebenfalls den Mutex verwenden, um Schreib-/Lese-Konflikte zu vermeiden.

### Teil B: Web-Frontend (HTML & JavaScript)

**1. HTML-Struktur:**
   - Erweitere die `index.html`-Seite (gehalten in `webconfig.hpp`) um zwei Hauptbereiche:
     - Einen `<canvas id="panelSimulator">`-Bereich für die Panel-Vorschau.
     - Einen `<pre id="logOutput">`-Bereich (oder ein ähnliches Textfeld) für die Log-Ausgaben.
   - Füge einen Button hinzu, um die WebSocket-Verbindung manuell zu starten/stoppen.

**2. JavaScript-Logik:**
   - **WebSocket-Handling:** Das Skript soll eine WebSocket-Verbindung zum `/stream`-Endpunkt aufbauen.
   - **Nachrichten-Dispatcher:** Der `onmessage`-Handler muss zwischen Text- (Log) und Binär-Nachrichten (Panel) unterscheiden.
     - Bei einer Textnachricht (JSON): Parsen und den Inhalt an das `#logOutput`-Feld anhängen.
     - Bei einer Binärnachricht: Den RLE-Decoder aufrufen.
   - **Panel-Rendering:**
     - Einmalig beim Start: Zeichne den Hintergrund des Simulators und ein Gitter aus dunkelgrauen Kreisen, die die "ausgeschalteten" LEDs darstellen.
     - **RLE-Decoder:** Implementiere die Logik, die den komprimierten Binärstrom liest, die `control bytes` interpretiert und die Farb- und Positionsdaten extrahiert.
     - Für jeden dekodierten farbigen Pixel: Zeichne den entsprechenden Kreis im LED-Gitter mit der übermittelten Farbe. Pixel mit dem Wert 0 (schwarz) werden ignoriert, sodass die dunkelgraue "Aus"-LED sichtbar bleibt.

Bitte setze diesen Plan Schritt für Schritt um und stelle die notwendigen Code-Änderungen für die genannten Dateien bereit.